[["intro.html", "Chapter 1 시계열 첫걸음, 관련 패키지의 이해 1.1 tsibble, feasts 그리고 fable 패키지 1.2 fpp3 패키지 1.3 tsible 객체 1.4 csv 파일로부터 tsibble 객체 만들기 연습 1.5 Time plots 1.6 시계열 자료 구성 요소 1.7 Seasonal plot 1.8 Scatter plots 1.9 Lag plots 1.10 Autocorrelation", " Chapter 1 시계열 첫걸음, 관련 패키지의 이해 1.1 tsibble, feasts 그리고 fable 패키지 시계열과 관련 된 R 패키지는 정말 많이 있다. 그 중에서 가장 유명한 패키지는 forecast 패키지이다. fpp 2판에서 메인 패키지로 활용되었던 forecast 패키지는 예측성능이 좋기로 유명하다. 하지만 forecast는 base 패키지를 기반으로 짜여져있는 패키지라서 fpp 3판에서 사용하게 될 패키지는 tsibble과 feasts, 그리고 fable 패키지를 주로 사용하게 될 예정이다. 세가지 패키지 모두 tidyverse스러운 코딩과 잘 맞는 함수들을 지원하는 것이 특징이다. 주의하기 forecast 패키지는 다른 언어를 사용하는 커뮤니티에도 알려질 정도로 잘 짜여진 패키지이다. 꼭 한번은 사용법을 알아둘 것을 추천한다. fpp 2판의 한글판을 봐두는 것도 나쁘지 않는 선택이다. tsibble 패키지는 tidyverse의 대표 객체인 tibble을 시계열 데이터를 잘 다룰수 있도록 조정한 tsibble 객체를 지원한다. feasts 패키지는 Feature Extraction And Statistics for Time Series의 줄임말로 시계열 데이터에서 특징을 뽑아내는데 사용된다. acf 함수라던지 lag 그래프를 그리는데에 사용된다. fable은 시계열 모델링에 관한 함수들이 모여져 있는 패키지이다. ARIMA, ETS와 같은 모델링 함수들을 가지고 있다. 1.2 fpp3 패키지 fpp3 패키지는 Hyndman 교수와 Athanasopoulos 교수가 지은 Forecasting: principles and practice 3판에 딸림 R 패키지라고 생각하면 된다. fpp3 패키지를 로드시키면 앞에서 말했던 tsibble과 feasts, 그리고 fable 패키지가 같이 로드된다. library(fpp3) 1.3 tsible 객체 y &lt;- tsibble( year = 2015:2019, observation = c(123, 39, 78, 52, 110), index = year ) y #&gt; # A tsibble: 5 x 2 [1Y] #&gt; year observation #&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 2015 123 #&gt; 2 2016 39 #&gt; 3 2017 78 #&gt; 4 2018 52 #&gt; 5 2019 110 tibble 객체를 확장 시킨 tidyverse용 데이터 프레임. y변수를 선언할 때 어떤 열을 index로 할 것인지 선언해 줌. [1Y]라는 것을 보고 관찰값이 1년 단위 관측되었다는 것을 알 수 있음. tsibbledata 패키지에 들어있는 olympic_running 데이터를 살펴보자. olympic_running #&gt; # A tsibble: 312 x 4 [4Y] #&gt; # Key: Length, Sex [14] #&gt; Year Length Sex Time #&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 1896 100 men 12 #&gt; 2 1900 100 men 11 #&gt; 3 1904 100 men 11 #&gt; 4 1908 100 men 10.8 #&gt; 5 1912 100 men 10.8 #&gt; 6 1916 100 men NA #&gt; 7 1920 100 men 10.8 #&gt; 8 1924 100 men 10.6 #&gt; 9 1928 100 men 10.8 #&gt; 10 1932 100 men 10.3 #&gt; # ... with 302 more rows 위의 결과값을 보면 key 변수가 2개 (Length, Sex) 로 설정이 되어있고, [14]라는 표시가 보인다. 이것은 두 개의 변수가 갖는 unique한 값들로 조합 할 수 있는 경우의 수가 14가지 경우가 된다는 것을 의미한다. 다음을 살펴보자. olympic_running %&gt;% distinct(Length) #&gt; # A tibble: 7 x 1 #&gt; Length #&gt; &lt;int&gt; #&gt; 1 100 #&gt; 2 200 #&gt; 3 400 #&gt; 4 800 #&gt; 5 1500 #&gt; 6 5000 #&gt; 7 10000 olympic_running %&gt;% distinct(Sex) #&gt; # A tibble: 2 x 1 #&gt; Sex #&gt; &lt;chr&gt; #&gt; 1 men #&gt; 2 women 1.4 csv 파일로부터 tsibble 객체 만들기 연습 prison &lt;- readr::read_csv(&quot;https://OTexts.com/fpp3/extrafiles/prison_population.csv&quot;) head(prison) #&gt; # A tibble: 6 x 6 #&gt; Date State Gender Legal Indigenous Count #&gt; &lt;date&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 2005-03-01 ACT Female Remanded ATSI 0 #&gt; 2 2005-03-01 ACT Female Remanded Non-ATSI 2 #&gt; 3 2005-03-01 ACT Female Sentenced ATSI 0 #&gt; 4 2005-03-01 ACT Female Sentenced Non-ATSI 5 #&gt; 5 2005-03-01 ACT Male Remanded ATSI 7 #&gt; 6 2005-03-01 ACT Male Remanded Non-ATSI 58 prison 변수에는 csv 파일로부터 불러온 시계열 정보가 들어있다. 날짜정보가 들어있는 첫번째 열을 인덱스로, count 정보를 제외한 나머지 열들을 key로 설정하여 tsibble로 바꿔보도록 하자. prison %&lt;&gt;% janitor::clean_names() %&gt;% mutate(quarter = yearquarter(date), .keep = &quot;unused&quot;) %&gt;% as_tsibble(key = state:indigenous, index = quarter) prison #&gt; # A tsibble: 3,072 x 6 [1Q] #&gt; # Key: state, gender, legal, indigenous [64] #&gt; state gender legal indigenous count quarter #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;qtr&gt; #&gt; 1 ACT Female Remanded ATSI 0 2005 Q1 #&gt; 2 ACT Female Remanded ATSI 1 2005 Q2 #&gt; 3 ACT Female Remanded ATSI 0 2005 Q3 #&gt; 4 ACT Female Remanded ATSI 0 2005 Q4 #&gt; 5 ACT Female Remanded ATSI 1 2006 Q1 #&gt; 6 ACT Female Remanded ATSI 1 2006 Q2 #&gt; 7 ACT Female Remanded ATSI 1 2006 Q3 #&gt; 8 ACT Female Remanded ATSI 0 2006 Q4 #&gt; 9 ACT Female Remanded ATSI 0 2007 Q1 #&gt; 10 ACT Female Remanded ATSI 1 2007 Q2 #&gt; # ... with 3,062 more rows 분기별 데이터를 yearquarter 사용해서 설정해줬던 것 처럼 다음 표과 같이 여러 시간 간격을 설정할 수 있는 함수를 tsibble 패키지에서는 제공한다. 자신의 데이터에 맞는 시간 간격을 설정해서 사용하자. 표 1.1: tsibble 객체에 부여할 수 있는 시간 간격 종류들 Frequency Function Annual start:end Quarterly yearquarter() Monthly yearmonth() Weekly yearweek() Daily as_date(), ymd() Sub-daily as_datetime(), ymd_hms() 1.5 Time plots 시계열에서 제일 기본적인 그래프이다. 시간에 따라서 우리가 보고싶은 반응 변수값을 그려준다. 앞에서 정의한 prison 시계열 데이터에서 특정 그룹의 시간에 따른 죄수 수의 변화를 그려보자. prison %&gt;% filter(state == &quot;ACT&quot;, gender == &quot;Female&quot;, legal ==&quot;Remanded&quot;, indigenous == &quot;ATSI&quot;) %&gt;% autoplot(count) + labs(title = &quot;시간에 따른 죄수 인구의 변화&quot;, y = &quot;죄수 (명)&quot;, x = &quot;시간 (분기)&quot;) 1.6 시계열 자료 구성 요소 추세 (Trend): 전반적인 방향성의 존재 유무 계절성 (Seasonal): 계절에 따른 반복유무 (고정 빈도) 주기성(cycle): 고정된 빈도가 아닌 증가, 감소 형태 1.7 Seasonal plot vic_elec 데이터는 호주의 빅토리아 주의 전력 수요량을 30분 단위로 기록한 데이터이다. head(vic_elec) #&gt; # A tsibble: 6 x 5 [30m] &lt;Australia/Melbourne&gt; #&gt; Time Demand Temperature Date Holiday #&gt; &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;date&gt; &lt;lgl&gt; #&gt; 1 2012-01-01 00:00:00 4383. 21.4 2012-01-01 TRUE #&gt; 2 2012-01-01 00:30:00 4263. 21.0 2012-01-01 TRUE #&gt; 3 2012-01-01 01:00:00 4049. 20.7 2012-01-01 TRUE #&gt; 4 2012-01-01 01:30:00 3878. 20.6 2012-01-01 TRUE #&gt; 5 2012-01-01 02:00:00 4036. 20.4 2012-01-01 TRUE #&gt; 6 2012-01-01 02:30:00 3866. 20.2 2012-01-01 TRUE 이 자료에서 하루를 기준으로 전력 수요가 어떠한 패턴으로 움직이는지 보고싶을 때 계절성 그래프 (Seasonal plot)가 유용함. vic_elec %&gt;% janitor::clean_names() %&gt;% filter(year(time) == 2012) %&gt;% gg_season(demand, period = &quot;day&quot;) + theme(legend.position = &quot;none&quot;) + labs(y=&quot;MWh&quot;, title=&quot;Electricity demand: Victoria&quot;) 그림 1.1: 하루 기준 전력 수요량의 변화 패턴 한 주를 기준으로 그려보면 새로운 패턴을 발견할 수 있다. vic_elec %&gt;% janitor::clean_names() %&gt;% filter(year(time) == 2012) %&gt;% gg_season(demand, period = &quot;week&quot;) + theme(legend.position = &quot;none&quot;) + labs(y=&quot;MWh&quot;, title=&quot;Electricity demand: Victoria&quot;) 그림 1.2: 한주 기준 전력 수요량의 변화 패턴 혼자 학습하기 연도를 기준으로 계절성 그래프를 그려보고, 계절에 따른 전력 수요량 패턴을 해석해보자. 1.8 Scatter plots 전력 수요량 데이터의 경우 전력 수요량을 나타내는 demand 변수가 존재하고, 이에 대응하는 temperature 변수가 존재한다. 두 개의 변수를 독립적으로 시계열 데이터로 보고 시간 그래프를 그려보면 다음과 같을 것이다. vic_elec %&gt;% janitor::clean_names() %&gt;% filter(year(time) == 2012) %&gt;% autoplot(demand) + labs(y = &quot;GW&quot;, title = &quot;Half-hourly electricity demand: Victoria&quot;) vic_elec %&gt;% janitor::clean_names() %&gt;% filter(year(time) == 2012) %&gt;% autoplot(temperature) + labs(y = &quot;Degrees Celsius&quot;, title = &quot;Half-hourly electricity demand: Victoria&quot;) 하지만, 위의 두 그래프를 시간 변수를 무시한 채 산점도를 그려보면 어떻게 될까? 다음과 같이 산점도를 그릴 경우 온도와 전력 수요량 간의 새로운 패턴을 발견 할 수 있다. vic_elec %&gt;% janitor::clean_names() %&gt;% filter(year(time) == 2012) %&gt;% ggplot(aes(x = temperature, y = demand)) + geom_point() + labs(x = &quot;Temperature (degrees Celsius)&quot;, y = &quot;Electricity demand (GW)&quot;) 전력수요량의 경우 온도가 낮은 경우와 높은 경우 증가하는 2차 곡선 형태의 패턴을 보인다. 이것은 겨울철 난방과 여름철 냉방을 위한 전력 수요에 기인한 것으로 보인다. prison %&gt;% group_by(state) %&gt;% summarise(count = sum(count)) %&gt;% ggplot(aes(x = quarter, y = count)) + geom_line() + facet_grid(vars(state), scales = &quot;free_y&quot;) + labs(title = &quot;Australian prison population by states&quot;, y= &quot;population&quot;) 1.9 Lag plots 다음은 Lag plots을 공부해보자. 이것을 이해하기 위해서는 먼저 Lag라는 것은 무엇인가를 이해해야 하는데, 사실 lag라는 단어는 대한민국 모든 사람이 알고 있는 단어이다. 왜냐하면 컴퓨터 렉 걸렸어! 라고 할 때 렉이 바로 영어로 lag이기 때문. Lag는 뒤쳐지다라는 뜻인데, 어떤 시계열 벡터가 있을 때, 특정 시점을 기준으로 이전 시점을 가리킨다. 쉽게 생각해서 시차라고 생각해 볼 수 있다. 예를 들어, 다음과 같은 숫자들이 있다고 하자. 1, 3, 6, 10, 15, 21, 28, 36, 45, 55 위의 숫자들을 시계열 벡터 x라고 할 때, x 벡터에 대응하는 lag 1, lag 2 벡터는 다음과 같다. x &lt;- c(1,3,6,10,15,21,28,36,45,55) lag_x_1 &lt;- lag(x, n = 1) lag_x_2 &lt;- lag(x, n = 2) 표 1.2: x에 대한 lag 1, lag 2 벡터 x lag1 lag2 1 NA NA 3 1 NA 6 3 1 10 6 3 15 10 6 21 15 10 28 21 15 36 28 21 45 36 28 55 45 36 Lag 플랏은 시계열 벡터와 각 lag 값에 대응하는 벡터를 사용하여 산점도를 그려준다. 이 그래프를 사용하면 좋은 점은 데이터의 주기성을 다시 확인 할 수 있다는 점이다. 다음은 호주의 분기별 맥주 생산량 정보를 담고 있는 aus_production 데이터이다. lag plot은 다음과 같이 맥주 생산량 데이터의 계절성을 체크하는데 유용하게 사용할 수 있다. lag 4와 lag 8을 살펴보면 대각선을 따라서 점들이 분포하는 것을 알 수 있다. 반대로 lag 2와 lag 4의 경우에는 좌에서 우로 뻗어 내리는 대각선 형태로 점들이 분포한 것을 알 수 있다. aus_production %&gt;% janitor::clean_names() %&gt;% filter(year(quarter) &gt;= 2000) %&gt;% gg_lag(beer, geom = &quot;point&quot;) + labs(x = &quot;lag(Beer, k)&quot;) 슬기로운 통계생활에서 진행하는 R을 사용한 기초 통계 수업 을 충실히 이수한 분이라면 특정 lag에 따라서 상관계수의 절대값이 크게 나올 것이라는 생각을 할 수 있을 것이다. 이러한 현상과 관련이 있는 개념이 바로 시계열에서의 자기 상관성이다. 1.10 Autocorrelation 기초 통계 시간에 배웠던 상관계수를 구하는 식을 살펴보자. 다음과 같이 \\(\\underline{x}=\\{x_1, x_2, ..., x_n\\}\\)와 \\(\\underline{y}=\\{y_1, y_2, ..., y_n\\}\\)의 \\(n\\)개의 표본이 주어졌을 때, 두 벡터의 표본 상관계수를 구하는 식은 다음과 같다. \\[ {\\displaystyle r_{xy}={\\frac {\\sum _{i=1}^{n}(x_{i}-{\\bar {x}})(y_{i}-{\\bar {y}})}{{\\sqrt {\\sum _{i=1}^{n}(x_{i}-{\\bar {x}})^{2}}}{\\sqrt {\\sum _{i=1}^{n}(y_{i}-{\\bar {y}})^{2}}}}}} \\] 자기 상관성은 특정 lag 값에 대응하는 벡터와 자기 자신과의 상관계수를 측정한 값으로 이해할 수 있다. lag \\(k\\)에 대한 (표본) 자기 상관계수 \\(r_k\\)는 다음과 같이 계산 할 수 있다. \\[ r_{k}=\\frac{\\sum_{t=k+1}^{T}\\left(x_{t}-\\overline{x}\\right)\\left(x_{t-k}-\\overline{x}\\right)}{\\sum_{t=1}^{T}\\left(x_{t}-\\overline{x}\\right)^{2}} \\] 분자에 위치한 summation기호는 \\(k+1\\) 부터 시작하고, 분모는 \\(1\\)부터 시작하는 것에 주의하자. 앞에서 정의한 x 벡터의 \\(r_2\\)를 계산하면 다음과 같다. # ACF 값 직접 구하기: r_2 sum((x - mean(x)) * (lag(x, n = 2) - mean(x)), na.rm = TRUE) / (var(x) * (length(x) - 1)) #&gt; [1] 0.3971631 위와 같은 자기 상관계수 값은 k값이 주어지면 값이 나오는 함수 형태로 볼 수 있다. 우리는 이것을 자기상관함수(autocorrelation function)라고 부른다. 자기상관함수 값은 ACF 함수를 사용해 다음과 같이 구할 수 있다. my_x &lt;- tsibble(value = x, time = 1:length(x), index = time) my_x %&gt;% ACF(value, lag_max = 9) #&gt; # A tsibble: 9 x 2 [1] #&gt; lag acf #&gt; &lt;lag&gt; &lt;dbl&gt; #&gt; 1 1 0.691 #&gt; 2 2 0.397 #&gt; 3 3 0.131 #&gt; 4 4 -0.0941 #&gt; 5 5 -0.266 #&gt; 6 6 -0.373 #&gt; 7 7 -0.406 #&gt; 8 8 -0.358 #&gt; 9 9 -0.223 이론상으로 자기상관계수는 주어진 벡터의 길이보다 하나 작은 \\(n-1\\) 시점까지 자기 상관계수를 구할 수 있는데, autoplot()은 이 값들을 각 시점마다 바차트 형태로 표현해 준다. my_x %&gt;% ACF(value, lag_max = 9) %&gt;% autoplot() + labs(title = &quot;x 벡터의 자기상관함수&quot;, x = &quot;Time lags&quot;, y = &quot;Autocorrelation function&quot;) 이러한 자기상관함수 그래프는 시계열 데이터의 특징을 파악하는데에 중요한 역할을 하게 된다. 또한 , 이러한 특성을 잘 잡아내기 때문에 ACF 함수의 형태를 기준으로 시계열 데이터를 분류하는데에도 사용된다. "]]
